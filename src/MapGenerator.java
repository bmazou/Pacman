import java.util.ArrayList;

public class MapGenerator {
    private static int MAP_WIDTH; 
    private static int MAP_HEIGHT;
    private static final float BRANCH_CHANCE = 0.1f;    
    private static final int MAX_BRANCHES = 4;    

    private static ArrayList<Integer> xBranches;
    private static ArrayList<Integer> yBranches;

    private static short[][] curMap;

    public static void generateMap() {
        /**
         * Generate a random map
         * <p>
         * The map is generated by:
         * - Generating a random width and height
         * - Filling the edges of the map with walls
         * - For each wall, generating a random position to spawn a branch from  
         * - Branching from each wall
         */
        MAP_WIDTH = (int) (Math.random() * 23 + 8);
        MAP_HEIGHT = (int) (Math.random() * 18 + 8);
        xBranches = new ArrayList<>();
        yBranches = new ArrayList<>();
        curMap = new short[MAP_HEIGHT][MAP_WIDTH];

        fillEdges();

        int[] spawnPositions = generateSpawnPositions();

        // If the map is wider than it is tall, it generates better when starting from the left and right walls
        // and after that from the top and bottom walls
        if (MAP_HEIGHT < MAP_WIDTH) {
            branchRandomlyFromWall(Direction.LEFT, spawnPositions[2]);
            branchRandomlyFromWall(Direction.RIGHT, spawnPositions[3]);
            branchRandomlyFromWall(Direction.UP, spawnPositions[0]);
            branchRandomlyFromWall(Direction.DOWN, spawnPositions[1]);
        }else {
            branchRandomlyFromWall(Direction.UP, spawnPositions[0]);
            branchRandomlyFromWall(Direction.DOWN, spawnPositions[1]);
            branchRandomlyFromWall(Direction.LEFT, spawnPositions[2]);
            branchRandomlyFromWall(Direction.RIGHT, spawnPositions[3]);
        }
    }

    private static void fillEdges() {
        /**
         * Fill the edges of the map with empty tiles
         * <p>
         * The edges are filled with empty tiles to prevent dead ends and to make sure the map makes sense
         * Also store the starting positions of the walls in the xBranches and yBranches lists, to prevent other branches from spawning on/next to them  
         */
        for (int i = 0; i < MAP_WIDTH; i++) {
            curMap[0][i] = 1;
            curMap[MAP_HEIGHT - 1][i] = 1;
        }
        yBranches.add(0);
        yBranches.add(MAP_HEIGHT - 1);

        for (int i = 0; i < MAP_HEIGHT; i++) {
            curMap[i][0] = 1;
            curMap[i][MAP_WIDTH - 1] = 1;
        }
        xBranches.add(0);
        xBranches.add(MAP_WIDTH - 1);
    }

    private static int[] generateSpawnPositions() {
        /**
         * Generate random spawn positions for the walls
         * <p>
         * The spawn positions are generated randomly, but are not allowed to be on/next to each other or on/next to the edges of the map
         * Also store the starting positions of the walls in the xBranches and yBranches lists, to prevent other branches from spawning on/next to them
         * 
         * @return An array containing the a random position for each wall
         */
        int[] positions = new int[4];

        // Generate x positions
        int randXPos = (int) (Math.random() * (MAP_WIDTH-4) + 2);   // Generates a random number between 2 and MAP_WIDTH - 2
        positions[0] = randXPos;
        xBranches.add(randXPos);
        
        do {
            randXPos = (int) (Math.random() * (MAP_WIDTH-4) + 2);
        } while (neigboursXBranches(randXPos));
        positions[1] = randXPos;
        xBranches.add(randXPos);


        // Generate y positions
        int randYPos = (int) (Math.random() * (MAP_HEIGHT-4) + 2);   // Generates a random number between 2 and MAP_HEIGHT - 2
        positions[2] = randYPos;
        yBranches.add(randYPos);

        do {
            randYPos = (int) (Math.random() * (MAP_HEIGHT-4) + 2);
        } while (neigboursYBranches(randYPos));
        positions[3] = randYPos;
        yBranches.add(randYPos);

        return positions;
    }


    private static void branchRandomlyFromWall(Direction dir, int spawnPos) {
        /**
         * Branch out from a wall
         * <p>
         * It takes a wall and a spawn position and branches out from that wall in the opposite direction
         * e.g. if it takes Direction.LEFT, it spawns on the left wall and branches out to the right
         * 
         * @param dir The direction of the wall
         * @param spawnPos The random position on the wall where the branch will spawn
         */
        switch (dir) {
            case UP:
                branchOut(1, spawnPos, dir.opposite(), MAX_BRANCHES);
                break;
            case DOWN:
                branchOut(MAP_HEIGHT - 2, spawnPos, dir.opposite(), MAX_BRANCHES);
                break;
            case LEFT:
                branchOut(spawnPos, 1, dir.opposite(), MAX_BRANCHES);
                break;
            case RIGHT:
                branchOut(spawnPos, MAP_WIDTH - 2, dir.opposite(), MAX_BRANCHES);
                break;
            default:
                break;
        }
    }


    private static boolean shouldBranch() {
        /**
         * Decide whether or not to branch, based on the BRANCH_CHANCE constant
         * 
         * @return True if the branch should branch, false otherwise
         */
        return Math.random() < BRANCH_CHANCE;
    }

    private static boolean neigboursXBranches(int x) {
        /**
         * Check if current x position collides with a branch
         * <p>
         * It cannot be on the same or neigbouring x position of an already created branch
         * 
         * @param x The x position to check
         * @return True if the x position collides with a branch, false otherwise
         */
        return xBranches.contains(x) || xBranches.contains(x - 1) || xBranches.contains(x + 1);
    }

    private static boolean neigboursYBranches(int y) {
        /**
         * Check if current y position collides with a branch
         * <p>
         * It cannot be on the same or neigbouring y position of an already created branch
         * 
         * @param y The y position to check
         * @return True if the y position collides with a branch, false otherwise
         */
        return yBranches.contains(y) || yBranches.contains(y - 1) || yBranches.contains(y + 1);
    }

    // Can branch, if it doesn't neigbour a column/row that has already been branched
    // ie we don't want to have two branches next to each other 
    private static boolean canBranchHere(int y, int x, Direction dir) {
        /**
         * Check if the current position is a valid position to branch from
         * <p>
         * It cannot be on the same or neigbouring position of an already created branch
         * 
         * @param y The y position to check
         * @param x The x position to check
         * @param dir The direction of the current branch
         * @return True if the position is valid, false otherwise
         */
        if (dir == Direction.LEFT || dir == Direction.RIGHT) {
            return !neigboursXBranches(x);
        } else {
            return !neigboursYBranches(y);
        }
    }

    private static void branchOut(int y, int x, Direction dir, int branchesLeft) {
        /**
         * Branch out from a position
         * <p>
         * It takes a position and a direction
         * Changes the current position to path
         * Tries to branch in the right and left perpendicular directions, if it doesn't collide with another branch and if there are still branches left to create
         * 
         * @param y Current y position
         * @param x Current x position
         * @param dir Current direction
         * @param branchesLeft The number of branches left it can create 
         */
        if (branchesLeft < 0) return;

        if (Map.isOutOfBounds(y, x)) {
            return;
        }

        curMap[y][x] = 1;

        if (canBranchHere(y, x, dir)) {
            // Try to branch in the right perpendicular direction
            if (branchesLeft > 0) {     
                if (tryToBranch(y, x, dir.next(), branchesLeft - 1)) branchesLeft--;
            }

            // Try to branch in the left perpendicular direction
            if (branchesLeft > 0) {
                if (tryToBranch(y, x, dir.prev(), branchesLeft - 1)) branchesLeft--;
            }
        }

        branchInDirection(y, x, dir, branchesLeft);
    }

    private static boolean tryToBranch(int y, int x, Direction newDir, int branchesLeft) {
        /**
         * Try to branch in a new direction
         * <p>
         * If it passes the random shouldBranch() check, it starts a new branch in the new direction
         * Returns true or false depending on whether or not it branched
         * 
         * @param y Current y position
         * @param x Current x position
         * @param newDir The new direction to potentially branch in
         * @param branchesLeft The number of branches left it can create
         * @return True if it branched, false if not
         */
        if (shouldBranch()) {
            addToBranches(y, x, newDir);
            branchInDirection(y, x, newDir, branchesLeft);
            return true;
        }
        return false;
    } 

    private static void branchInDirection(int y, int x, Direction dir, int branchesLeft) {
        /**
         * Branches in a direction
         * <p>
         * It takes a position and a direction
         * Calculates the next position based on the direction
         * 
         * @param y Current y position
         * @param x Current x position
         * @param dir Current direction
         * @param branchesLeft The number of branches left it can create 
         */
        int nextX = x + dir.dx();
        int nextY = y + dir.dy();
        branchOut(nextY, nextX, dir, branchesLeft);
    }

    private static void addToBranches(int y, int x, Direction dir) {
        /**
         * Adds a new branch to the list of created branches
         * 
         * @param y The y position of the branch
         * @param x The x position of the branch
         * @param dir The direction of the branch
         */
        if (dir == Direction.LEFT || dir == Direction.RIGHT) {
            yBranches.add(y);
        } else {
            xBranches.add(x);
        }
    }


    //* ----------------- GETTERS ----------------- *//
    public static int getMapWidth() {
        /**
         * Get the width of the map
         * 
         * @return The width of the map
         */
        return MAP_WIDTH;
    }

    public static int getMapHeight() {
        /**
         * Get the height of the map
         * 
         * @return The height of the map
         */
        return MAP_HEIGHT;
    }

    public static short[][] getMap() {
        /**
         * Get the map
         * 
         * @return The map
         */
        short[][] temp = new short[MAP_HEIGHT][MAP_WIDTH];
        for (int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                temp[i][j] = (short) curMap[i][j];
            }
        }

        return temp;
    }
}
